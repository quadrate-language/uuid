/// UUID generation (version 4 random UUIDs).
/// Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
use mem
use rand
use str

/// Generate a new random UUIDv4 string.
/// @return uuid str UUID string (36 chars)
/// @example uuid::v4 -> id
pub fn v4( -- uuid:str) {
	rand::new -> rng

	// Generate 16 random bytes
	16 mem::alloc! -> bytes
	0 16 1 for it {
		it -> i
		rng 256 rand::int -> b -> rng
		b bytes i mem::set_byte
	}

	// Set version (4) in byte 6: xxxx4xxx
	bytes 6 mem::get_byte -> b6
	b6 15 and 64 or -> b6  // Clear high nibble, set to 4
	b6 bytes 6 mem::set_byte

	// Set variant (RFC 4122) in byte 8: 10xxxxxx
	bytes 8 mem::get_byte -> b8
	b8 63 and 128 or -> b8  // Clear top 2 bits, set to 10
	b8 bytes 8 mem::set_byte

	// Convert to hex string with dashes
	// Format: 8-4-4-4-12 (total 32 hex + 4 dashes = 36 chars)
	36 mem::alloc! -> out
	0 -> o

	// Hex lookup
	16 mem::alloc! -> hex
	48 hex 0 mem::set_byte   // '0'
	49 hex 1 mem::set_byte   // '1'
	50 hex 2 mem::set_byte   // '2'
	51 hex 3 mem::set_byte   // '3'
	52 hex 4 mem::set_byte   // '4'
	53 hex 5 mem::set_byte   // '5'
	54 hex 6 mem::set_byte   // '6'
	55 hex 7 mem::set_byte   // '7'
	56 hex 8 mem::set_byte   // '8'
	57 hex 9 mem::set_byte   // '9'
	97 hex 10 mem::set_byte  // 'a'
	98 hex 11 mem::set_byte  // 'b'
	99 hex 12 mem::set_byte  // 'c'
	100 hex 13 mem::set_byte // 'd'
	101 hex 14 mem::set_byte // 'e'
	102 hex 15 mem::set_byte // 'f'

	// Bytes 0-3 (8 hex chars)
	0 4 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	// Dash
	45 out o mem::set_byte  // '-'
	o 1 + -> o

	// Bytes 4-5 (4 hex chars)
	4 6 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	// Dash
	45 out o mem::set_byte
	o 1 + -> o

	// Bytes 6-7 (4 hex chars)
	6 8 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	// Dash
	45 out o mem::set_byte
	o 1 + -> o

	// Bytes 8-9 (4 hex chars)
	8 10 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	// Dash
	45 out o mem::set_byte
	o 1 + -> o

	// Bytes 10-15 (12 hex chars)
	10 16 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	out 36 mem::to_string -> result

	// Cleanup
	bytes mem::free
	hex mem::free
	out mem::free

	result
}

/// Generate UUID with specific seed (for reproducibility).
/// @param seed i64 Seed value
/// @return uuid str UUID string (36 chars)
/// @example 12345 uuid::v4_seeded -> id
pub fn v4_seeded(seed:i64 -- uuid:str) {
	-> seed
	seed rand::with_seed -> rng

	// Generate 16 random bytes
	16 mem::alloc! -> bytes
	0 16 1 for it {
		it -> i
		rng 256 rand::int -> b -> rng
		b bytes i mem::set_byte
	}

	// Set version (4) in byte 6
	bytes 6 mem::get_byte -> b6
	b6 15 and 64 or -> b6
	b6 bytes 6 mem::set_byte

	// Set variant in byte 8
	bytes 8 mem::get_byte -> b8
	b8 63 and 128 or -> b8
	b8 bytes 8 mem::set_byte

	// Convert to hex string
	36 mem::alloc! -> out
	0 -> o

	16 mem::alloc! -> hex
	48 hex 0 mem::set_byte
	49 hex 1 mem::set_byte
	50 hex 2 mem::set_byte
	51 hex 3 mem::set_byte
	52 hex 4 mem::set_byte
	53 hex 5 mem::set_byte
	54 hex 6 mem::set_byte
	55 hex 7 mem::set_byte
	56 hex 8 mem::set_byte
	57 hex 9 mem::set_byte
	97 hex 10 mem::set_byte
	98 hex 11 mem::set_byte
	99 hex 12 mem::set_byte
	100 hex 13 mem::set_byte
	101 hex 14 mem::set_byte
	102 hex 15 mem::set_byte

	0 4 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}
	45 out o mem::set_byte
	o 1 + -> o

	4 6 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}
	45 out o mem::set_byte
	o 1 + -> o

	6 8 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}
	45 out o mem::set_byte
	o 1 + -> o

	8 10 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}
	45 out o mem::set_byte
	o 1 + -> o

	10 16 1 for it {
		it -> i
		bytes i mem::get_byte -> b
		hex b 4 shr 15 and mem::get_byte -> hi
		hex b 15 and mem::get_byte -> lo
		hi out o mem::set_byte
		o 1 + -> o
		lo out o mem::set_byte
		o 1 + -> o
	}

	out 36 mem::to_string -> result
	bytes mem::free
	hex mem::free
	out mem::free
	result
}

/// Check if a string is a valid UUID format.
/// @param s str String to check
/// @return valid i64 1 if valid format, 0 otherwise
/// @example "550e8400-e29b-41d4-a716-446655440000" uuid::is_valid -> result
pub fn is_valid(s:str -- valid:i64) {
	-> s
	s str::len 36 != if {
		0
	} else {
		1 -> result
		// Check dashes at positions 8, 13, 18, 23
		s 8 str::char_at! 45 != if {
			0 -> result
		}
		s 13 str::char_at! 45 != if {
			0 -> result
		}
		s 18 str::char_at! 45 != if {
			0 -> result
		}
		s 23 str::char_at! 45 != if {
			0 -> result
		}
		result
	}
}
